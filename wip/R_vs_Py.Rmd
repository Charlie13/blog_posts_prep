---
title: "R vs. Python"
author: "Dr. Shirin Glander"
date: '`r Sys.Date()`'
output:
  prettydoc::html_pretty:
    theme: tactile
    highlight: github
---

I am an avid R user and rarely use anything else for data analysis and visualisation.

I wanted to test whether my bias for using R is founded in good reason or whether Python might be faster/ easier for some cases.

Therefore, I am following [Zhuyi Xue's "A Comprehensive Introduction To Your Genome With the SciPy Stack"](https://www.toptal.com/python/comprehensive-introduction-your-genome-scipy) (with some minor tweaks here and there) to compare his analysis with how I would run it in (base) R. I want to know whether one or the other tool is better suited to this type of analysis.

He gives a nice introduction to the data, so I will not repeat it here but focus on the comparison with R.

For R, I am working with RStudio, for Python with Anaconda and Spyder.

### Reading in data

Reading in data as csv files is straight forward in both R and Python with the exception that R opens compressed files without having to specify the compression format as in Python/pandas.

```{python eval = FALSE}
import pandas as pd

df = pd.read_csv('../../Homo_sapiens.GRCh38.85.gff3.gz', 
                         compression = 'gzip',
                         sep = '\t', 
                         comment = '#', 
                         low_memory = False,
                         header = None, 
                         names = ['seqid', 'source', 'type', 'start', 'end', 'score', 'strand', 'phase', 'attributes'])
df.head()
```

```{r cache=TRUE}
df <- read.csv("../../Homo_sapiens.GRCh38.85.gff3.gz", 
               header = FALSE, 
               sep = "\t", 
               col.names = c('seqid', 'source', 'type', 'start', 'end', 'score', 'strand', 'phase', 'attributes'), 
               comment.char = "#")
head(df)
```

### Examining data

- listing unique strings of "seqid" column

```{python eval=FALSE}
df.seqid.unique() # alternatively: df['seqid'].unique()
```

```{r}
unique(df$seqid)
```

- how many unique seqids are there?

```{python eval=FALSE}
df.seqid.unique().shape
```

```{r}
length(unique(df$seqid))
```

- counting occurrences of items in the "source" column

```{python eval=FALSE}
df.source.value_counts()
```

```{r}
table(df$source)

# is per default ordered alphabetically, if we want it ordered by decreasing counts, like with Python:
sort(table(df$source), decreasing = TRUE)
```

#### How Much of the Genome Is Incomplete?

- subsetting a dataframe

```{python eval=FALSE}
gdf = df[df.source == 'GRCh38']

gdf.shape
gdf.sample(10)
```

```{r}
# either
gdf <- df[df$source == "GRCh38", ]

# or
gdf <- subset(df, source == "GRCh38")

# get number of rows and columns
dim(gdf)

# randomly sample 10 rows for observation
gdf[sample(nrow(gdf), 10), ]
```

Viewing 10 random lines is more straight forward in Python but in R I'd usually use head() to get an idea of a dataframe.

- calculate the sum of seqid lengths

```{python eval=FALSE}
gdf = gdf.copy()
gdf['length'] = gdf.end - gdf.start + 1

gdf.length.sum()
```

```{r}
gdf$length <- gdf$end - gdf$start + 1

sum(gdf$length)
```

In R we don't need to copy the dataframe first.

- calculate the proportio of the genome that is not on main chromosome assemblies

```{python eval=FALSE}
chrs = [str(_) for _ in range(1, 23)] + ['X', 'Y', 'MT']
gdf[-gdf.seqid.isin(chrs)].length.sum() / gdf.length.sum()

# or
gdf[(gdf['type'] == 'supercontig')].length.sum() / gdf.length.sum()
```

```{r}
chrs <- c(1:23, "X", "Y", "MT")
sum(gdf[-which(gdf$seqid %in% chrs), "length"]) / sum(gdf$length)

sum(gdf[which(gdf$type == "supercontig"), "length"]) / sum(gdf$length)
```

#### How Many Genes Are There?

```{python eval=FALSE}
edf = df[df.source.isin(['ensembl', 'havana', 'ensembl_havana'])]
edf.sample(10)
edf.type.value_counts()
```

```{r}
edf <- subset(df, source %in% c("ensembl", "havana", "ensembl_havana"))
edf[sample(nrow(edf), 10), ]
sort(table(edf$type), decreasing = TRUE)
```

```{python eval=FALSE}
ndf = edf[edf.type == 'gene']
ndf = ndf.copy()
ndf.sample(10).attributes.values
```

```{r}
ndf <- subset(df, type == "gene")
ndf[sample(nrow(ndf), 10), "attributes"]
```

- extracting gene information from attributes field

I don't know if there is an easier way in Python but in R we don't need to create a helper function around it. We can simply use gsub()...

```{python eval=FALSE}
import re

RE_GENE_NAME = re.compile(r'Name=(?P<gene_name>.+?);')
def extract_gene_name(attributes_str):
    res = RE_GENE_NAME.search(attributes_str)
    return res.group('gene_name')


ndf['gene_name'] = ndf.attributes.apply(extract_gene_name)

RE_GENE_ID = re.compile(r'gene_id=(?P<gene_id>ENSG.+?);')
def extract_gene_id(attributes_str):
    res = RE_GENE_ID.search(attributes_str)
    return res.group('gene_id')


ndf['gene_id'] = ndf.attributes.apply(extract_gene_id)


RE_DESC = re.compile('description=(?P<desc>.+?);')
def extract_description(attributes_str):
    res = RE_DESC.search(attributes_str)
    if res is None:
        return ''
    else:
        return res.group('desc')


ndf['desc'] = ndf.attributes.apply(extract_description)

ndf.drop('attributes', axis=1, inplace=True)
ndf.head()
```

```{r}
ndf$gene_name <- gsub("(.*Name=)(.*?)(;biotype.*)", "\\2", ndf$attributes)
ndf$gene_id <- gsub("(ID=gene:)(.*?)(;Name.*)", "\\2", ndf$attributes)
ndf$desc <- gsub("(.*description=)(.*?)(;.*)", "\\2", ndf$attributes)

# some genes don't have a description
ndf$desc <- ifelse(grepl("^ID=.*", ndf$desc), "", ndf$desc)

ndf <- subset(ndf, select = -attributes)
head(ndf, n = 10)
```

```{python eval=FALSE}
ndf.shape
ndf.gene_id.unique().shape
ndf.gene_name.unique().shape

count_df = ndf.groupby('gene_name').count().ix[:, 0].sort_values().ix[::-1]
count_df.head(10)
```

```{r}
dim(ndf)
length(unique(ndf$gene_id))
length(unique(ndf$gene_name))
```

