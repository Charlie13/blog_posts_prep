---
title: "R vs. Python"
author: "Dr. Shirin Glander"
date: '`r Sys.Date()`'
output:
  prettydoc::html_pretty:
    theme: tactile
    highlight: github
---

I am an avid R user and rarely use anything else for data analysis and visualisation.

I wanted to test whether my bias for using R is founded in good reason or whether Python might be faster/ easier for some cases.

Therefore, I am following [Zhuyi Xue's "A Comprehensive Introduction To Your Genome With the SciPy Stack"](https://www.toptal.com/python/comprehensive-introduction-your-genome-scipy) (with some minor tweaks here and there) to compare his analysis with how I would run it in R. I want to know whether one or the other tool is better suited to this type of analysis.

He gives a nice introduction to the data, so I will not repeat it here but focus on the comparison with R.

For R, I am working with RStudio, for Python with Anaconda and Spyder.

While the code could be replicated with base R, I find it more elegant to use dplyr and ggplot2.

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
```


### Reading in data

Reading in data as csv files is straight forward in both R and Python with the exception that R opens compressed files without having to specify the compression format as in Python/pandas.

```{python eval = FALSE}
import pandas as pd

df = pd.read_csv('../../Homo_sapiens.GRCh38.85.gff3.gz', 
                         compression = 'gzip',
                         sep = '\t', 
                         comment = '#', 
                         low_memory = False,
                         header = None, 
                         names = ['seqid', 'source', 'type', 'start', 'end', 'score', 'strand', 'phase', 'attributes'])
df.head()
```

```{r cache=TRUE}
df <- read.csv("../../Homo_sapiens.GRCh38.85.gff3.gz", 
               header = FALSE, 
               sep = "\t", 
               col.names = c('seqid', 'source', 'type', 'start', 'end', 'score', 'strand', 'phase', 'attributes'), 
               comment.char = "#")
head(df)
```

### Examining data

- listing unique strings of "seqid" column

```{python eval=FALSE}
df.seqid.unique() # alternatively: df['seqid'].unique()
```

```{r}
unique(df$seqid)
```

- how many unique seqids are there?

```{python eval=FALSE}
df.seqid.unique().shape
```

```{r}
length(unique(df$seqid))
```

- counting occurrences of items in the "source" column

```{python eval=FALSE}
df.source.value_counts()
```

```{r}
# table(df$source) is per default ordered alphabetically, if we want it ordered by decreasing counts, like with Python:
sort(table(df$source), decreasing = TRUE)
```

#### How Much of the Genome Is Incomplete?

- subsetting a dataframe

```{python eval=FALSE}
gdf = df[df.source == 'GRCh38']

gdf.shape
gdf.sample(10)
```

```{r}
gdf <- subset(df, source == "GRCh38")

# get number of rows and columns
dim(gdf)

# randomly sample 10 rows for observation
sample_n(gdf, 10)
```

Viewing 10 random lines is more straight forward in Python but in R I'd usually use head() to get an idea of a dataframe.

- calculate the sum of seqid lengths

```{python eval=FALSE}
gdf = gdf.copy()
gdf['length'] = gdf.end - gdf.start + 1

gdf.length.sum()
```

```{r}
gdf$length <- gdf$end - gdf$start + 1

sum(gdf$length)
```

In R we don't need to copy the dataframe first.

- calculate the proportio of the genome that is not on main chromosome assemblies

```{python eval=FALSE}
chrs = [str(_) for _ in range(1, 23)] + ['X', 'Y', 'MT']
gdf[-gdf.seqid.isin(chrs)].length.sum() / gdf.length.sum()

# or
gdf[(gdf['type'] == 'supercontig')].length.sum() / gdf.length.sum()
```

```{r}
chrs <- c(1:23, "X", "Y", "MT")
sum(subset(gdf, !seqid %in% chrs)$length) / sum(gdf$length)
```

#### How Many Genes Are There?

```{python eval=FALSE}
edf = df[df.source.isin(['ensembl', 'havana', 'ensembl_havana'])]
edf.shape

edf.sample(10)
edf.type.value_counts()
```

```{r}
edf <- subset(df, source %in% c("ensembl", "havana", "ensembl_havana"))
dim(edf)

sample_n(edf, 10)
sort(table(edf$type), decreasing = TRUE)
```

```{python eval=FALSE}
ndf = edf[edf.type == 'gene']
ndf = ndf.copy()
ndf.sample(10).attributes.values
ndf.shape
```

```{r}
ndf <- subset(edf, type == "gene")
sample_n(ndf, 10)$attributes
dim(ndf)
```

- extracting gene information from attributes field

I don't know if there is an easier way in Python but in R we don't need to create a helper function around it. We can simply use gsub()...

```{python eval=FALSE}
import re

RE_GENE_NAME = re.compile(r'Name=(?P<gene_name>.+?);')
def extract_gene_name(attributes_str):
    res = RE_GENE_NAME.search(attributes_str)
    return res.group('gene_name')


ndf['gene_name'] = ndf.attributes.apply(extract_gene_name)

RE_GENE_ID = re.compile(r'gene_id=(?P<gene_id>ENSG.+?);')
def extract_gene_id(attributes_str):
    res = RE_GENE_ID.search(attributes_str)
    return res.group('gene_id')


ndf['gene_id'] = ndf.attributes.apply(extract_gene_id)


RE_DESC = re.compile('description=(?P<desc>.+?);')
def extract_description(attributes_str):
    res = RE_DESC.search(attributes_str)
    if res is None:
        return ''
    else:
        return res.group('desc')


ndf['desc'] = ndf.attributes.apply(extract_description)

ndf.drop('attributes', axis=1, inplace=True)
ndf.head()
```

```{r}
ndf$gene_name <- gsub("(.*Name=)(.*?)(;biotype.*)", "\\2", ndf$attributes)
ndf$gene_id <- gsub("(ID=gene:)(.*?)(;Name.*)", "\\2", ndf$attributes)
ndf$desc <- gsub("(.*description=)(.*?)(;.*)", "\\2", ndf$attributes)

# some genes don't have a description
ndf$desc <- ifelse(grepl("^ID=.*", ndf$desc), "", ndf$desc)

ndf <- subset(ndf, select = -attributes)
head(ndf, n = 10)
```

```{python eval=FALSE}
ndf.shape
ndf.gene_id.unique().shape
ndf.gene_name.unique().shape

count_df = ndf.groupby('gene_name').count().ix[:, 0].sort_values().ix[::-1]
count_df.head(10)
```

```{r}
dim(ndf)
length(unique(ndf$gene_id))
length(unique(ndf$gene_name))
```

#### How Long Is a Typical Gene?

```{python eval=FALSE}
ndf['length'] = ndf.end - ndf.start + 1
ndf.length.describe()
```

```{r}
ndf$length <- ndf$end - ndf$start + 1
summary(ndf$length)
```

R's summary() is not exactly the same as Python's describe() but it's close enough.

```{python eval=FALSE}
import matplotlib as plt

ndf.length.plot(kind='hist', bins=50, logy=True)
plt.show()
```

In base R you can't really plot a histogram with logarithmic y-axis scales (and it isn't recommended either because 0 will become -Inf) but you can do it easily with ggplot2.

```{r message=FALSE, warning=FALSE}
ggplot(ndf, aes(x = length)) + 
  geom_histogram(bins = 50, fill = "blue") + 
  scale_y_log10()
```

```{python eval=FALSE}
ndf[ndf.length > 2e6].sort_values('length').ix[::-1]
```

```{r}
ndf %>%
  filter(length > 2e6) %>%
  arrange(desc(length))
```

```{python eval=FALSE}
ndf.sort_values('length').head()
```

```{r}
head(arrange(ndf, length))
```

#### Gene Distribution Among Chromosomes

```{python eval=FALSE}
ndf = ndf[ndf.seqid.isin(chrs)]
chr_gene_counts = ndf.groupby('seqid').count().ix[:, 0].sort_values().ix[::-1]
chr_gene_counts
```

```{r}
ndf$seqid <- as.character(ndf$seqid) # as factors it will subset the dataframe but keep the factor levels
ndf <- subset(ndf, seqid %in% chrs)
chr_gene_counts <- sort(table(ndf$seqid), decreasing = TRUE)
chr_gene_counts
```

```{python eval=FALSE}
df[(df.type == 'gene') & (df.seqid == 'MT')]
```

```{r}
subset(df, type == "gene" & seqid == "MT")
```

```{python eval=FALSE}
gdf = gdf[gdf.seqid.isin(chrs)]
gdf.drop(['start', 'end', 'score', 'strand', 'phase' ,'attributes'], axis=1, inplace=True)
gdf.sort_values('length').ix[::-1]
```

```{r}
gdf$seqid <- as.character(gdf$seqid) # as factors it will subset the dataframe but keep the factor levels
gdf <- subset(gdf, as.character(seqid) %in% chrs) %>%
  select(-(start:attributes))
arrange(gdf, desc(length))
```

```{python eval=FALSE}
cdf = chr_gene_counts.to_frame(name='gene_count').reset_index()
cdf.head(2)

merged = gdf.merge(cdf, on='seqid')

```

```{r}
cdf <- as.data.frame(chr_gene_counts)
colnames(cdf) <- c("seqid", "gene_count")
head(cdf, n = 2)

merged <- merge(gdf, cdf, by = "seqid")
merged
```

```{python eval=FALSE}
merged[['length', 'gene_count']].corr()
```

```{r}
cor(merged[, c("length", "gene_count")])
```

```{python eval=FALSE}
ax = merged[['length', 'gene_count']].sort_values('length').plot(x='length', y='gene_count', style='o-')
# add some margin to both ends of x axis
xlim = ax.get_xlim()
margin = xlim[0] * 0.1
ax.set_xlim([xlim[0] - margin, xlim[1] + margin])
# Label each point on the graph
for (s, x, y) in merged[['seqid', 'length', 'gene_count']].sort_values('length').values:
    ax.text(x, y - 100, str(s))
```

```{r}
merged[, c("seqid", "length", "gene_count")] %>%
  arrange(desc(length)) %>%
  ggplot(aes(x = length, y = gene_count, label = seqid)) +
  geom_point(color = "blue") +
  geom_line(color = "blue") +
  geom_text()
```

