---
title: "Network analysis of Game of Thrones family ties"
author: "Dr. Shirin Glander"
date: "May 8, 2017"
output: html_document
---

In this post, I am exploring network analysis techniques in a family network of major characters from Game of Thrones.

<br>

## What is a network?

A network in this context is a graph of interconnected nodes/vertices. Nodes can e.g. be people in a social network, genes in a co-expression network, etc. Nodes are connected via ties/edges. 

<br>

## What can network analysis tell us?

Network analysis can e.g. be used to explore relationships in social or professional networks. There, we would typically ask questions like:

- How many connections does each person have?
- Who is the most connected (i.e. influential or "important") person?
- Are there clusters of tightly connected people?
- Are there a few key players that connect clusters of people?
- etc.

These answers can give us a lot of information about the patterns of how people interact.
nternational Network for Social Network Analysis, ‘Social network analysis is focused on uncovering the patterning of people's interaction’.

<br>

## The Game of Thrones character network

The basis for this network is [Kaggle's Game of Throne dataset](https://www.kaggle.com/mylesoneill/game-of-thrones) but because most family relationships were missing in that dataset, I added the missing information in part by hand (based on [A Wiki of Ice and Fire](http://awoiaf.westeros.org/)) and by scraping information from [the Game of Thrones wiki](http://gameofthrones.wikia.com). You can find the full code for how I generated the network [on my Github page](https://github.com/ShirinG/blog_posts_prep/blob/master/GoT/got.Rmd).

- add link to github

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(igraph)
library(statnet)
```

```{r}
load("union_edges.RData")
load("union_characters.RData")
```

<br>

I am using **igraph** to plot the network. To do so, I first create the graph from the edge- and nodetable. An edgetable contains source and target nodes in the first two columns and optinally additional columns with edge attributes. Here, I have the type of interaction (mother, father or spouse), the color and linetype I want to assign to each edge.

Because the books and the TV series differ slightly, I have introduced edges that are only supported or hinted at by the TV series and are not part of the original narrative in the books. These edges are marked by being dotted instead of solid. An additional color for edges with unspecified parental origin are introduced as well. Originally, these served for interactions that were extracted from character names (i.e. characters that ended with "... son/daughter of ...") and could either mean mother or father. Now, they show unclear parentage or cases where there are a biological and a de facto father, as in the case of Jon Snow.

```{r}
head(union_edges)
```

The nodetable contains one row for each character that is either a source or a target in the edgetable. We can give any number and type of node attribute but here, I chose 
the followin columns from the original Kaggle dataset: gender/male (male = 1, female = 0), house (as the house each character was born into) and popularity. House2 was meant to assign a color to only the major houses. Shape represents the gender.

```{r}
head(union_characters)
```

By default, we have a directed graph.

```{r}
union_graph <- graph_from_data_frame(union_edges, directed = TRUE, vertices = union_characters)
```

For plotting the legend, I am summarising the edge and node colors.

```{r}
color_vertices <- union_characters %>%
  group_by(house, color) %>%
  summarise(n = n()) %>%
  filter(!is.na(color))

colors_edges <- union_edges %>%
  group_by(type, color) %>%
  summarise(n = n()) %>%
  filter(!is.na(color))
```

Now, we can plot the graph object:

```{r fig.width=40, fig.height=40}
pdf("family_tree_GoT.pdf", width = 35, height = 35)
plot(union_graph,
     vertex.label = gsub(" ", "\n", V(union_graph)$name),
     vertex.shape = V(union_graph)$shape,
     vertex.color = V(union_graph)$color, 
     vertex.size = (V(union_graph)$popularity + 0.5) * 5, 
     vertex.frame.color = "gray", 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8,
     edge.arrow.size = 0.5,
     edge.color = E(union_graph)$color,
     edge.lty = E(union_graph)$lty)
legend("topleft", legend = c("Node color:", as.character(color_vertices$house), NA, "Edge color:", as.character(colors_edges$type)), pch = 19,
       col = c(NA, color_vertices$color, NA, NA, colors_edges$color), pt.cex = 2, cex = 1, bty = "n", ncol = 1)
dev.off()
```

- add image here

Node color shows the major houses, node size the character's popularity and node shape their gender (square for male, circle for female). Edge color shows interaction type.

As we can see, even with only a subset of characters from the Game of Thrones world, the network is already quite big. You can click on the image to open the pdf and zoom into specific parts of the plot and read the node labels/character names.

What we can see right away, is that the Greyjoys are the only house that has no ties to any of the others.

<br>

### Node degree

> "The degree of a vertex is its most basic structural property, the number of its adjacent edges." From the help pages of *degree()*

We can calculate the number of out- or ingoing edges of each node, or - as I am doing here - the sum of both.

```{r}
union_graph_degree <- igraph::degree(union_graph, mode = "total")
```

```{r}
data.frame(degree = union_graph_degree) %>%
  tibble::rownames_to_column() %>%
  arrange(-degree) %>%
  .[1:10, ]
```

In this case, the node degree tells us how many offspring and spouses a character had. With 3 wifes and several children, Quellon Greyjoy, the grandfather of Theon and Asha/Yara comes out on top (of course, had I included all offspring and wifes of Walder Frey's, he would easily be on top but the network would have gotten infintely more confusing).

```{r fig.width=35, fig.height=35, echo=FALSE, eval=FALSE}
plot(union_graph,
     vertex.label = gsub(" ", "\n", V(union_graph)$name),
     vertex.shape = V(union_graph)$shape,
     vertex.color = V(union_graph)$color, 
     vertex.size = union_graph_degree, 
     vertex.frame.color = "gray", 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8,
     edge.arrow.mode = E(union_graph)$arrow,
     edge.arrow.size = 0.5,
     edge.color = E(union_graph)$color,
     edge.lty = E(union_graph)$lty)
legend("topleft", legend = c("Node color:", as.character(color_vertices$house), NA, "Edge color:", as.character(colors_edges$type)), pch = 19,
       col = c(NA, color_vertices$color, NA, NA, colors_edges$color), pt.cex = 2, cex = 1, bty = "n", ncol = 1)
```

<br>

### Betweenness centrality

Nodes with high betweenness centrality are on the path between many other nodes, i.e. they are people who are key connections or bridges between different groups of nodes. In a social network, these nodes would be very important e.g. as targets for advertisement, because they are likely to pass on information to a wide reach of people.

The **igraph** function *betweenness()* calculates vertex betweenness, *edge_betweenness()* calculates edge betweenness:

> "The vertex and edge betweenness are (roughly) defined by the number of geodesics (shortest paths) going through a vertex or an edge." igraph help for *estimate_betweenness()*

```{r}
node_betweenness <- igraph::betweenness(union_graph)

data.frame(betweenness = node_betweenness) %>%
  tibble::rownames_to_column() %>%
  arrange(-betweenness) %>%
  .[1:10, ]
```

```{r}
edge_betweenness <- igraph::edge_betweenness(union_graph)

data.frame(edge = attr(E(union_graph), "vnames"),
           betweenness = edge_betweenness) %>%
  tibble::rownames_to_column() %>%
  arrange(-betweenness) %>%
  .[1:10, ]
```

This, we can now plot by feeding the node betweenness as vertex.size and edge betweenness as edge.width to our plot function:

```{r fig.width=35, fig.height=35}
plot(union_graph,
     vertex.label = gsub(" ", "\n", V(union_graph)$name),
     vertex.shape = V(union_graph)$shape,
     vertex.color = V(union_graph)$color, 
     vertex.size = node_betweenness * 0.05, 
     vertex.frame.color = "gray", 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8,
     edge.width = edge_betweenness * 0.5,
     edge.arrow.size = 0.5,
     edge.color = E(union_graph)$color,
     edge.lty = E(union_graph)$lty)
legend("topleft", legend = c("Node color:", as.character(color_vertices$house), NA, "Edge color:", as.character(colors_edges$type)), pch = 19,
       col = c(NA, color_vertices$color, NA, NA, colors_edges$color), pt.cex = 2, cex = 1, bty = "n", ncol = 1)
```

Ned Stark is the character with highest betweenness. This makes sense, as he and his children have connections to many of the other houses and are the central points from which the story unfolds. However, we have to keep in mind here, that my choice of who is important enough to include in the network (e.g. the Stark ancestors) and who not (e.g. the whole complicated mess that is the Targaryen and Frey family tree) makes this result somewhat biased.

<br>

### Diameter
 
In contrast to the shortest path between two nodes, we can also calculate the longest path, or diameter:

```{r}
diameter(union_graph)
```

> "get_diameter returns a path with the actual diameter. If there are many shortest paths of the length of the diameter, then it returns the first one found." *diameter()* help

```{r}
node_diameter <- get.diameter(union_graph)
```

This, we can also plot:

```{r fig.width=35, fig.height=35}
union_graph_diameter <- union_graph

V(union_graph_diameter)$color <- scales::alpha(V(union_graph_diameter)$color, alpha = 0.5)
V(union_graph_diameter)$size <- 2

V(union_graph_diameter)[node_diameter]$color <- "red"
V(union_graph_diameter)[node_diameter]$size <- 5

E(union_graph_diameter)$color <- scales::alpha(E(union_graph_diameter)$color, alpha = 0.5) 
E(union_graph_diameter)$width <- 1

E(union_graph_diameter, path = node_diameter)$color <- "red"
E(union_graph_diameter, path = node_diameter)$width <- 5

plot(union_graph_diameter,
     vertex.label = gsub(" ", "\n", V(union_graph_diameter)$name),
     vertex.shape = V(union_graph_diameter)$shape,
     vertex.frame.color = "gray", 
     vertex.label.color = "black", 
     vertex.label.cex = 0.8,
     edge.arrow.size = 0.5,
     edge.lty = E(union_graph_diameter)$lty)
legend("topleft", legend = c("Node color:", as.character(color_vertices$house), NA, "Edge color:", as.character(colors_edges$type)), pch = 19,
       col = c(NA, color_vertices$color, NA, NA, colors_edges$color), pt.cex = 2, cex = 1, bty = "n", ncol = 1)
```

<br>

### Transitivity

> "Transitivity measures the probability that the adjacent vertices of a vertex are connected. This is sometimes also called the clustering coefficient." *transitivity()* help

We can calculate the transitivity for the whole network:

```{r}
transitivity(union_graph)
```

Or for each node:

```{r}
data.frame(name = V(union_graph)$name,
      transitivity = transitivity(union_graph, type = "local")) %>%
  arrange(-transitivity)
```

<br>

### Centrality

> "Centralization is a method for creating a graph level centralization measure from the centrality scores of the vertices." *centralize()* help

```{r}
centr_degree(union_graph, mode = "total")$centralization
centr_clo(union_graph, mode = "total")$centralization

centr_eigen(union_graph, directed = TRUE)$centralization
```

<br>

### Matrix representation of a network

Connections between nodes can also be represented as an adjacency matrix. We can convert our graph object to an adjacency matrix with **igraph**'s *as_adjacency_matrix()* function. Whenever there is an edge between two nodes, this field in the matrix will get assigned a 1, otherwise it is 0.

```{r}
adjacency <- as.matrix(as_adjacency_matrix(union_graph))
```

<br>

### Network properties

We can, for example, feed our adjacency matrix to other functions, like *GenInd()* from the **NetIndices** packages. This function calculates a number of network properties, like number of compartments (N), total system throughput (T..), total system throughflow (TST), number of internal links (Lint), total number of links (Ltot), like density (LD), connectance (C), average link weight (Tijbar), average compartment throughflow (TSTbar) and compartmentalization or degree of connectedness of subsystems in the network (Cbar).

```{r warning=FALSE, message=FALSE}
library(NetIndices)
graph.properties <- GenInd(adjacency)
graph.properties
```

<br>

Alternatively, the **network** package provides additional functions to obtain network properties. Here, we can again feed in the adjacency matrix of our network.

```{r warning=FALSE, message=FALSE}
library(network)
adj_network <- network(adjacency, directed = TRUE)
```

From this network object, we can e.g. get the number of dyads and edges within a network and the network size.

```{r warning=FALSE, message=FALSE}
adj_network
network.dyadcount(adj_network)
network.edgecount(adj_network)
network.size(adj_network)
```

```{r warning=FALSE, message=FALSE, echo=FALSE, eval=FALSE}
library(sna)
library(rgl)
gplot3d(adj_network, gmode = "digraph", displaylabels = TRUE, jitter = TRUE)

geodist(adjacency)
```

From the **sna** package, we can e.g. use functions that tell us the graph density and the dyadic reciprocity of the vertices or edges

```{r}
gden(adjacency)
grecip(adjacency)
grecip(adjacency, measure = "edgewise")
```

<br>

### Groups of nodes

We can also analyze dyads (pairs of two nodes), triads (groups of three nodes) and bigger cliques in our network. For dyads, we can use the function *dyad_census()* from **igraph** or *dyad.census()* from **sna**. Both are identical and calculate a Holland and Leinhardt dyad census with

- mut: The number of pairs with mutual connections (in our case, spouses).
- asym: The number of pairs with non-mutual connections (in our case, mother-child and father-child relationships).
- null: The number of pairs with no connection between them.

```{r}
#igraph::dyad_census(union_graph)
sna::dyad.census(adjacency)
```

The same can be calculated for triads (see `?triad_census` for details on what each output means). While our original network was plotted as a directed network to show mother-child/father-child relationships as directional for plotting, it makes sense that we consider our network as undirected now that we want to analyze the network probabilities.

```{r}
#igraph::triad_census(union_graph)
sna::triad.census(adjacency)
triad.classify(adjacency, mode = "graph")
```

We can also calculate the number of paths and cycles of any length we specify, here e.g. of length <= 5. For edges, we obtain the sum of counts for all paths or cycles up to the given maximum length. For vertices/nodes, we obtain the number of paths or cycles to which each node belongs.

```{r}
node_kpath <- kpath.census(adjacency, maxlen = 5, mode = "graph", tabulate.by.vertex = TRUE, dyadic.tabulation = "sum")
edge_kpath <- kpath.census(adjacency, maxlen = 5, mode = "graph", tabulate.by.vertex = FALSE)
edge_kpath
```

```{r fig.width=20, fig.height=20}
gplot(node_kpath$paths.bydyad,
      label.cex = 0.5, 
      vertex.cex = 0.75,
      displaylabels = TRUE,
      edge.col = "grey")
```

```{r}
node_kcycle <- kcycle.census(adjacency, maxlen = 5, mode = "graph", tabulate.by.vertex = TRUE, cycle.comembership = "sum")
edge_kcycle <- kcycle.census(adjacency, maxlen = 5, mode = "graph", tabulate.by.vertex = FALSE)
edge_kcycle
```

```{r fig.width=20, fig.height=20}
gplot(node_kcycle$cycle.comemb,
      label.cex = 0.5, 
      vertex.cex = 0.75,
      displaylabels = TRUE,
      edge.col = "grey")
```

> "A (maximal) clique is a maximal set of mutually adjacenct vertices." *clique.census()* help

```{r}
node_clique <- clique.census(adjacency, mode = "graph", tabulate.by.vertex = TRUE, clique.comembership = "sum")
edge_clique <- clique.census(adjacency, mode = "graph", tabulate.by.vertex = FALSE, clique.comembership = "sum")
edge_clique$clique.count
```

```{r fig.width=20, fig.height=20}
gplot(node_clique$clique.comemb,
      label.cex = 0.5, 
      vertex.cex = 0.75,
      displaylabels = TRUE,
      edge.col = "grey")
```

<br>

The number of connected components can again be calculated with both, **igraph** and **sna.

```{r}
# is our network strongly or weakly connected?
igraph::is.connected(union_graph, mode = "strong")
igraph::is.connected(union_graph, mode = "weak")

igraph::count_components(union_graph, mode = "strong")
comp <- igraph::components(union_graph, mode = "strong")
head(groups(comp))

comp_dist <- igraph::component_distribution(union_graph, mode = "strong")
comp_dist

#sna::components(adjacency)
```

```{r fig.width=20, fig.height=20, echo=FALSE, eval=FALSE}
reach <- reachability(adjacency, return.as.edgelist = TRUE)

gplot(reach,
      label.cex = 0.5, 
      vertex.cex = 0.75,
      edge.col = "grey")
```

```{r fig.width=20, fig.height=20, echo=FALSE, eval=FALSE}
kcores <- kcores(adjacency, mode = "graph")

gplot(adjacency,
      label.cex = 0.5, 
      vertex.cex = 0.75,
      edge.col = "grey",
      vertex.col = rainbow(max(kcores) + 1)[kcores + 1])
```

> "equiv.clust uses a definition of approximate equivalence (equiv.fun) to form a hierarchical clustering of network positions. Where dat consists of multiple relations, all specified relations are considered jointly in forming the equivalence clustering." *equiv.clust()* help

```{r fig.width=30, fig.height=10}
ec <- equiv.clust(adj_network, mode = "graph", cluster.method = "average", plabels = network.vertex.names(adj_network))
ec # The clustering
ec$cluster$labels <- ec$plabels
plot(ec) # Plot the dendrogram
```

> "Given a set of equivalence classes (in the form of an equiv.clust object, hclust object, or membership vector) and one or more graphs, blockmodel will form a blockmodel of the input graph(s) based on the classes in question, using the specified block content type. [...] Unless a vector of classes is specified, blockmodel forms its eponymous models by using cutree to cut an equivalence clustering in the fashion specified by k and h. After forming clusters (roles), the input graphs are reordered and blockmodel reduction is applied." *blockmodel()* help

```{r}
bm <- blockmodel(adj_network, ec, h = 5, plabels = network.vertex.names(adj_network))
bm_bm <- bm$block.model
bm_bm[is.nan(bm_bm)] <- 1

gplot(bm_bm, 
      diag = TRUE, 
      edge.lwd = bm_bm * 5,
      vertex.cex = sqrt(table(bm$block.membership)) / 2,
      gmode = "graph", 
      vertex.sides = 50, 
      vertex.col = gray(1 - diag(bm_bm)))
```

---


Betweenness is the number of shortest paths an actor is on (Conway, 2009).  For example, in the network depicted above, vertex 1 is on a path between 2 and 4 and another path between 3 and 4. Betweenness for vertex 1 is then equal to 2. There is another path between 2 and 4 via vertex 3, but it is not the shortest path, so it does not count. Similarly, 2 is on a path between 1 and 3, but its not as short as the direct path between 1 and 3.  Therefore, betweenness for the other vertices is zero, because all other vertices are at the end of a path, and are not on any of the shortest paths between vertices.

Degree Centrality is simply the number of connections (or edges) a vertex has to other vertices. Its clear from counting that #1’s degree centrality is 3, while vertex #4 has a measure of degree centrality equal to 1.

Eigenvector Centrality is a measure that reflects the fact that  not all connections are equal, and in fact, connections to people that are more influential are more important (Newman, 2012).  Mathematically, the measure of eigenvector centrality is derived from the weights that consist of the values from the leading eigenvector  (the eigenvector associated with the largest eigenvalue) of the adjacency matrix depicting the network.

Recall, the value λ is an eigenvalue (or vector of eigenvalues) of the matrix A, and x is an eigenvector of A if the following equation holds:

λ x = A x

So, for the network depicted above, the centrality measures for each vertex = 1,2,3,4 can be derived from the components (x1,x2,x3,x4) that comprise the eigenvector x.
Eigenvectors and eigenvalues can be derived by solving:

(A-λ I)x = 0
Fortunately, the adjacency matrix A can be specified in a matrix programming environment (like SAS or  R) and the values for λ and x can be easily calculated.

The absolute values are proportional to the measures of eigenvector centrality for each vertex in the network.

One way to identify key actors in a network is to compare relative values of centrality such as eigenvector centrality and betweenness. Its apparent that many measures of centrality are correlated (Valente et al, 2010). If we assume a linear relationship between eigenvector centrality and betweeness and regress betweeness on eigenvector centrality, the residuals can be used to identify key players (Conway, 2009).   A vertex or individual with higher levels of betweenness and lower EV centrality may be a ‘critical gatekeeper  or an individual that is central to the functioning of the network. Someone with lower levels of betweeness and higher EV centrality may have unique access to other individuals that are key to the functioning of the network (Conway, 2009).

Based on the code provide by Conway,  the igraph and ggplot packages in R can be used to create a plot that visualizes each vertex’s relative value of EV centrality and betweeness, scaled by the value of the regression residual.  

Centrality measures for each individual could easily be exported and incorporated into other analytic applications such as predictive modeling. Snapshots of network metrics, as well as network structure could be examined over time to evaluate policy impacts. These basic tools are only the beginning of possibilities for applications of SNA. 

– Avg. degree: the number of edges/connections attached to a node
– Network diameter: The longest path between the nodes in the graph
– Average path length: In how many steps (on avg) can one can reach any node from any other node in the graph
– Degree power law: The higher this number, the more unequal is the distribution of connections within the network, which means that some nodes are very well-connected and some are not at all
– Average clustering coefficient: Shows how well the nodes are embedded in their neighborhood i.e. is there a “small world” effect within the network
– Modularity: The higher this parameter, the more defined are the communities within the network. A result of 0.4 or more is usually considered meaningful
– Betweenness centrality was calculated for each node, which shows how often the node appears on the shortest path between any two random nodes in the network. The higher this parameter, the more influential the node is. The nodes which have high betweenness centrality are not necessarily the ones that have the most connections and don’t have to be the most “popular” ones Here’s a video of Gephi features (older version)

I was also able to discover interesting patterns in the data, like the communities that emerge, popular people and the connectors. See the graph below to see nodes with different colors (communities), size (popularity) and how most connections between the two communities flow through a few nodes (connections)

```{r}
EV <- eigen(adjacency) # compute eigenvalues and eigenvectors
max(as.numeric(EV$values))  # find the maximum eigenvalue

# get the eigenvector associated with the largest eigenvalue
centrality <- data.frame(EV$vectors[,1]) 
names(centrality) <- "Centrality"
print(centrality)
```

https://github.com/briatte/awesome-network-analysis#r

NetworkAnalyzer Online Help
Contents

NetworkAnalyzer Settings
Network Interpretations
Simple Network Parameters
Complex Network Parameters
Degree distributions
Neighborhood connectivity
Shortest paths
Clustering coefficients
Shared neighbors
Topological coefficients
Stress centrality
Betweenness centrality
Closeness centrality
Analysis of subset of nodes
Batch Analysis
Fitting a Line
Fitting a Power Law
Attributes
Visualizing Computed Parameters
Network Modifications
References
NetworkAnalyzer Settings

The following plugin settings can be configured by the user:

Store node / edge parameters in node / edge attributes
For every node in a network, NetworkAnalyzer computes its degree (in- and out-degrees for directed networks), its clustering coefficient, the number of self-loops, and a variety of other parameters. NetworkAnalyzer also computes edge betweenness for each edge in the network. If the respective options are enabled, NetworkAnalyzer stores the computed values as attributes of the corresponding nodes and edges. This enables the users to apply different visualizations or to filter nodes or edges based on the values of the computed attributes. For a complete list of the computed node and edge attributes, please see the section Attributes.

Use expandable interface for the dialog that displays analysis results
If this option is enabled, analysis results are presented in a window in which all charts are placed below each other in expandable boxes. If this option is disabled, analysis results are presented in a window that contains tabs for the group of simple parameters and for every complex parameter. Users who wish to view simultaneously two or more complex parameters of one network, should enable this option.

Change colors for parameter visualization
This options allow the user to change the default colors of parameter visualization. Please see the section Visualizing Computed Parameters for more details.

Background color
The color of the background in the network view. It is initially set to the default Cytoscape background color.

Bright color
This color defines the brightest color that parameters can be mapped to. By default its value is green.

Middle color
This color defines the intermediate color, that parameters can be mapped to. By default its value is yellow.

Dark color
This color defines the darkest color that parameters can be mapped to. By default its value is red.

Location of the help documents
URL of this help web page for NetworkAnalyzer. This also enables the local download and storage of this help page.

Network Interpretations

 directed network

(a)

 undirected network

(b)

Figure 1 Example of a directed network (a) and an undirected network (b).

NetworkAnalyzer can perform topological analysis on directed networks (containing only directed edges) as well as on undirected networks (containing only undirected edges). An example of a directed network and an undirected network is given in Figure 1a and Figure 1b, respectively.

In Cytoscape, a network may contain only directed edges even if they are undirected in their biological context. Moreover, one network may contain both directed and undirected edges if the network is compiled by combining data from different sources.

In the situations described above, NetworkAnalyzer needs user input how to interpret the edges. Figure 2 depicts two examples of small networks in Cytoscape and their interpretations.

In (a), the network contains solely directed edges. Here, NetworkAnalyzer provides three possible interpretations of the edge directions in the network. The user has to select one of the interpretations for further processing of the network.

In (b), the network contains both undirected and directed edges. Note that undirected edges cannot be converted unambiguously to directed ones. Therefore, networks with mixed edges are handled as undirected ones.

 network interpretations

(a)

network interpretations

(b)

Figure 2 (a) Network with directed paired edges and its three possible interpretations. (b) Network containing both directed and undirected edges and its interpretation as undirected.

Simple Network Parameters

Number of connected components
In undirected networks, two nodes are connected if there is a path of edges between them. Within a network, all nodes that are pairwise connected form a connected component. The number of connected components indicates the connectivity of a network – a lower number of connected components suggests a stronger connectivity.

Parameters related to shortest paths
The length of a path is the number of edges forming it. There may be multiple paths connecting two given nodes. The shortest path length, also called distance, between two nodes n and m is denoted by L(n,m). The network diameter is the largest distance between two nodes. If a network is disconnected, its diameter is the maximum of all diameters of its connected components. The diameter can also be described as the maximum node eccentricity (eccentricity is defined in the Attributes section). The network radius, on the other hand, is the minimum among the non-zero eccentricites of the nodes in the network. The average shortest path length, also known as the characteristic path length, gives the expected distance between two connected nodes.

Parameters related to neighborhood
The neighborhood of a given node n is the set of its neighbors. The connectivity of n, denoted by kn, is the size of its neighborhood. The average number of neighbors indicates the average connectivity of a node in the network. A normalized version of this parameter is the network density. The density is a value between 0 and 1. It shows how densely the network is populated with edges (self-loops and duplicated edges are ignored). A network which contains no edges and solely isolated nodes has a density of 0. In contrast, the density of a clique is 1.

The number of isolated nodes may provide insight how the network density is distributed. Another related parameter is the network centralization [6]. Networks whose topologies resemble a star have a centralization close to 1, whereas decentralized networks are characterized by having a centralization close to 0. The network heterogeneity [6] reflects the tendency of a network to contain hub nodes.

In addition, the number of multi-edge node pairs indicates how often neighboring nodes are linked by more than one edge.

Clustering coefficient
In undirected networks, the clustering coefficient Cn of a node n is defined as Cn = 2en/(kn(kn-1)), where kn is the number of neighbors of n and en is the number of connected pairs between all neighbors of n [17, 2]. In directed networks, the definition is slightly different: Cn = en/(kn(kn-1)).

In both cases, the clustering coefficient is a ratio N / M, where N is the number of edges between the neighbors of n, and M is the maximum number of edges that could possibly exist between the neighbors of n. The clustering coefficient of a node is always a number between 0 and 1.

The network clustering coefficient is the average of the clustering coefficients for all nodes in the network. Here, nodes with less than two neighbors are assumed to have a clustering coefficient of 0.

Complex Network Parameters

Degree distributions
In undirected networks, the node degree of a node n is the number of edges linked to n. A self-loop of a node is counted like two edges for the node degree [5]. The node degree distribution gives the number of nodes with degree k for k = 0,1,….

In directed networks, the in-degree of a node n is the number of incoming edges and the out-degree is the number of outgoing edges. Similar to undirected networks, there are an in-degree distribution and an out-degree distribution.

Barabási and Albert used the node degree distribution to distinguish between random (as defined by Erdős and Rényi [7, 3]) and scale-free network topologies [2].

Neighborhood connectivity
The connectivity of a node is the number of its neighbors. The neighborhood connectivity of a node n is defined as the average connectivity of all neighbors of n [10]. The neighborhood connectivity distribution gives the average of the neighborhood connectivities of all nodes n with k neighbors for k = 0,1,…. Figure 3 shows the neighborhood connectivity distribution for the network presented in Figure 1b.

NetworkAnalyzer computes similar parameters for directed networks. In analogy to the in- and out-degree, every node n in a directed network has in- and out-connectivity. Thus, in directed networks, a node has the following types of neighborhood connectivity:

only in - the average out-connectivity of all in-neighbors of n;
only out - the average in-connectivity of all out-neighbors of n;
in and out - the average connectivity of all neighbors of n (edge direction is ignored).
Based on the three definitions given above, there are three neighborhood connectivity distributions - "only in", "only out" and "in and out".

Figure 3
Figure 3 Neighborhood connectivity distribution of the network shown in Figure 1b.

If the neighborhood connectivity distribution is a decreasing function in k, edges between low connected and highly connected nodes prevail in the network [10].

Shortest paths
The length of the shortest path between two nodes n and m is L(n,m). The shortest path length distribution gives the number of node pairs (n,m) with L(n,m) = k for k = 1,2,….

The network diameter is the maximum length of shortest paths between two nodes. If a network is disconnected, its diameter is the maximum of all diameters of its connected components.

The network diameter and the shortest path length distribution may indicate small-world properties of the analyzed network [17].

Clustering coefficients
In undirected networks, the clustering coefficient Cn of a node n is defined as Cn = 2en/(kn(kn-1)), where kn is the number of neighbors of n and en is the number of connected pairs between all neighbors of n [17, 2]. In directed networks, the definition is slightly different: Cn = en/(kn(kn-1)).

In both cases, the clustering coefficient is a ratio N / M, where N is the number of edges between the neighbors of n, and M is the maximum number of edges that could possibly exist between the neighbors of n. The clustering coefficient of a node is always a number between 0 and 1.

The average clustering coefficient distribution gives the average of the clustering coefficients for all nodes n with k neighbors for k = 2,…. NetworkAnalyzer also computes the network clustering coefficient that is the average of the clustering coefficients for all nodes in the network.

The clustering coefficient of a node is the number of triangles (3-loops) that pass through this node, relative to the maximum number of 3-loops that could pass through the node.

Figure 4
Figure 4 Example network with four nodes and four edges.

For example, in Figure 4, there is one triangle that passes through node b (the triangle bcd). The maximum number of triangles that could pass through b is three (in this case, the pairs (a, c) and (a, d) would be connected additionally). This yields a clustering coefficient of Cb = 1 / 3.

Ravasz et al. used the average clustering coefficient distribution to identify a modular organization of metabolic networks [13].

Shared neighbors
P(n,m) is the number of partners shared between the nodes n and m, that is, nodes that are neighbors of both n and m. The shared neighbors distribution gives the number of node pairs (n,m) with P(n,m) = k for k = 1,….

If a motif like the one presented in Figure 5 is over-represented in a network, this can be inferred from the shared neighbors distribution.

Figure 5
Figure 5 Motif of two nodes sharing exactly four neighbors.

Topological coefficients
The topological coefficient [15] Tn of a node n with kn neighbors is computed as follows:
Tn = avg ( J(n,m) ) / kn.
Here, J(n,m) is defined for all nodes m that share at least one neighbor with n. The value J(n,m) is the number of neighbors shared between the nodes n and m, plus one if there is a direct link between n and m.

For example, in Figure 6, J(b,c) = J(b,d) = J(b,e) = 2. Therefore, Tb = 2 / 3.

The topological coefficient is a relative measure for the extent to which a node shares neighbors with other nodes. NetworkAnalyzer computes the topological coefficients for all nodes with more than one neighbor in the network. Nodes that have one or no neighbors are assigned a topological coefficient of 0 (zero).

Figure 6
Figure 6 Example network with five nodes and six edges.

The chart of the topological coefficients can be used to estimate the tendency of the nodes in the network to have shared neighbors.

Stress centrality
The stress centrality [4, 14] of a node n is the number of shortest paths passing through n. A node has a high stress if it is traversed by a high number of shortest paths. This parameter is defined only for networks without multiple edges.

The stress centraility distribution gives the number of nodes with stress s for different values of s. The values for the stress are grouped into bins whose size grows exponentially by a factor of 10. The bins used for this distribution are {0}; [1, 10); [10, 100); ...

Betweenness centrality
The betweenness centrality [4] Cb(n) of a node n is computed as follows:
Cb(n) = ∑s≠n≠t (σst (n) / σst),
where s and t are nodes in the network different from n, σst denotes the number of shortest paths from s to t, and σst (n) is the number of shortest paths from s to t that n lies on.

Betweenness centrality is computed only for networks that do not contain multiple edges. The betweenness value for each node n is normalized by dividing by the number of node pairs excluding n: (N-1)(N-2)/2, where N is the total number of nodes in the connected component that n belongs to. Thus, the betweenness centrality of each node is a number between 0 and 1.

For example, the betweenness centrality of node b in Figure 7 is computed as follows:
Cb(b) = ((σac(b) / σac) + (σad(b) / σad) + (σae(b) / σae) + (σcd(b) / σcd) + (σce(b) / σce) + (σde(b) / σde)) / 6 = ((1 / 1) + (1 / 1) + (2 / 2) + (1 / 2) + 0 + 0) / 6 = 3.5 / 6 ≈ 0.583

Figure 7
Figure 7 Example network with five nodes and five edges.

The betweenness centrality of a node reflects the amount of control that this node exerts over the interactions of other nodes in the network [19]. This measure favors nodes that join communities (dense subnetworks), rather than nodes that lie inside a community.

NetworkAnlayzer uses the fast algorithm by Brandes [4] for the computation of node betweenness centrality. This algorithm has a complexity of O(NM), N being the number of nodes and M - the number of edges in the network.

Closeness centrality
The closeness centrality [11] Cc(n) of a node n is defined as the reciprocal of the average shortest path length and is computed as follows:
Cc(n) = 1 / avg( L(n,m) ),
where L(n,m) is the length of the shortest path between two nodes n and m. The closeness centrality of each node is a number between 0 and 1.

NetworkAnalyzer computes the closeness centrality of all nodes and plots it against the number of neighbors. The closeness centrality of isolated nodes is equal to 0.

Closeness centrality is a measure of how fast information spreads from a given node to other reachable nodes in the network [11].

For example, the closeness centrality of node b in Figure 7 is computed as follows:
Cc(b) = 1/ ( (L(b, a) + L(b, c) + L(b, d) + L(b, e)) / 4) = 4/ (1 + 1 + 1 + 2) = 4/5 = 0.8

Analysis of subset of nodes

An exhaustive topological analysis of very large networks can be a time consuming task. The computation of local parameters for the nodes is significantly faster than the computation of global (path-related) parameters. Examples of local parameters are node degree, neighborhood connectivity, topological and clustering coefficients. Betweenness and closeness centralities, as well as stress, are global parameters.

NetworkAnalyzer provides the option "Analyze Subset of Nodes" for computing local parameters for a subset of nodes. If one or more nodes in the network are selected before starting an analysis, only the subnetwork induced by the selected nodes is analyzed. Moreover, only local parameters are computed. Shared neighbors distribution and shortest path lengths distribution, among others, are not displayed in the results.

Batch Analysis

The "Batch Analysis" menu item in NetworkAnalyzer is used to perform topological analysis on all networks stored in specific directory, using all possible interpretations for every network. Batch analysis consist of three simple steps:

Selecting directories
The user selects the input and output directories. The input directory should contain network files that can be loaded into Cytoscape. NetworkAnalyzer loads consecutively each of the networks it finds in the directory and performs topological analysis on it. Subdirectories of the input directory are not traversed. The output directory is the one that will contain all analysis results after the batch analysis. In order to avoid file overwriting, NetworkAnalyzer requires that the output directory is empty (contains no files) before the batch analysis starts.

Analysis
NetworkAnalyzer scans the input directory and loads all supported networks into Cytoscape, one at a time. Each loaded network is inspected and then it is analyzed considering all possible interpretations for it. The analysis step is complete after all networks are analyzed. Note that, depending on the number of networks and their sizes, this might be a very time-consuming step.

Inspection of results
After the analysis is complete, the button "Show Results" is enabled, and it displays the results dialog. The dialog contains a table of all topological analyses performed. Every row in the results table lists the loaded network, its interpretation and the resulting network statistics file that was saved in the output directory. By clicking on a network name and on statistics file name, the user can load the network and topology analysis results, respectively.

Fitting a Line

NetworkAnalyzer provides another useful feature - fitting a line on the data points of some complex parameters. The method applied is the least squares method for linear regression [18]. NetworkAnalyzer gives the correlation between the given data points and the corresponding points on the fitted line. In addition, the R-squared value (also known as coefficient of determination) is reported.

Fitting a line can be used to identify linear dependencies between the values of the x and y coordinates in a complex parameter. Figure 8 shows the fitted line on a neighborhood connectivity distribution. The correlation between the data points and corresponding points on the line is approximately 0.969. The R-squared value is 0.939, giving a relatively high confidence that the underlying model is indeed linear.

Figure 8
Figure 8 Neighborhood connectivity distribution of the network shown in Figure 1b, with a fitted line.

Fitting a Power Law

The degree distribution of many biological networks approximates a power law: DD(k) ~ kα for some negative constant α. Several studies have reported similar properties of the average clustering coefficient distribution [13] and the topological coefficients [15].

NetworkAnalyzer can fit a power law to some topological parameters. Please note that NetworkAnalyzer uses the least squares method [18], and only points with positive coordinate values are considered for the fit. This approach fits a line on logarithmized data and may be inappropriate for supporting certain hypotheses [8, 16].

NetworkAnalyzer gives the correlation between the given data points and the corresponding points on the fitted curve. In addition, the R-squared value (also known as coefficient of determination) is reported. This coefficient gives the proportion of variability in a data set, which is explained by a fitted linear model. Therefore, the R-squared value is computed on logarithmized data, where the power-law curve:
y = β xα
is transformed into linear model:
ln y = ln β + α ln x,
as shown in Figure 9.

Figure 9a

(a)

Figure 9b

(b)

Figure 9 (a) Neighborhood connectivity distribution of the network shown in Figure 1b, with a fitted power law. (b) The R-squared value reported is the R-squared value for the fitted line on logarithmized data.

Attributes

Node Attributes
While iterating over the connected components of a network, NetworkAnalyzer computes the following topological measures for each node n:

AverageShortestPathLength
Average length of a shortest path between n and any other node. If n is an isolated node, the value of this attribute is zero.

BetweennessCentrality
Betweenness centrality of n as explained in the section Betweenness centrality.

ClosenessCentrality
Closeness centrality of n as described in the section Closeness centrality.

ClusteringCoefficient
This numerical attribute stores the clustering coefficient of n, as defined in [2]. Nodes with less than 2 neighbors have a clustering coefficient of zero.

Degree
The degree of n as explained in the section Degree Distributions.

Eccentricity
The maximum non-infinite length of a shortest path between n and another node in the network. If n is an isolated node, the value of this attribute is zero.

IsSingleNode
This boolean attribute indicates if n is an isolated node, that is, if n has no neighbors.

NeighborhoodConnectivity
The neighborhood connectivity of n as explained in the section Neighborhood Connectivity.

NumberOfDirectedEdges
This attribute counts the number of directed edges that are connected to n.

NumberOfUndirectedEdges
This attribute counts the number of undirected edges that are connected to n.

PartnerOfMultiEdgedNodePairs
This attribute indicates if n is a partner of node pairs with multiple edges.

Radiality
This attribute is a node centrality index [4] computed by subtracting the average shortest path length of a node n from the diameter of the connected component plus 1. The radiality of each node is divided by the diameter of the connected component. Thus it is a number between 0 and 1.

SelfLoops
This attribute counts the number of self-loops at n.

Stress
This attribute counts the number of shortest paths passing through a node.

TopologicalCoefficient
This numerical attribute stores the topological coefficient of n, as defined in [15]. Nodes with less than 2 neighbors have a topological coefficient of zero.

Edge Attributes
While iterating over the connected components of a network, NetworkAnalyzer computes the following topological measures for each edge e:

EdgeBetweenness
This attribute stores the edge betweenness of each edge normalized by dividing by (M-1)(M-2), where M is the number	of edges in the connected component that the edge belongs to. The edge betweenness of e=(v,w) is defined as the number of shortest paths between two nodes s and t that go through e divided by the total number of shortest paths that go from s to t [12], [19].
Edge betweenness is computed only for networks that do not contain multiple edges. In addition, self-loops are neglected in the calculation.

Visualizing Computed Parameters

For a visual inspection of the results of a topological analysis, NetworkAnalyzer includes two options. On the one hand, the computed parameters can be visualized by mapping them to node/edge size and color. On the other hand, each pair of computed parameters can be plotted in a chart. Both types of visualizations can be applied to the attributes computed by NetworkAnalyzer, as well as to all other numerical attributes assigned to the nodes and edges of the network of interest.

Note that visual mapping is possible only when the computed parameters for the selected network are stored as node and edge attributes. Make sure the option "Store node / edge parameters in node / edge attributes" in NetwowkAnalyzer Settings is enabled. Parameters loaded from a .netstats file cannot be visualized because the network itself is not stored in the network statistics file. If, after performing topological analysis, the network is modified by introducing or removing nodes or edges, it is recommended (and sometimes required) to run NetworkAnalyzer again before visualizing any parameters.

Map Parameters to Visual Style
The visual mapping is initiated by the Map Parameters to Visual Style dialog, shown on Figure 10. There are two ways of mapping computed parameters.

Map to node / edge size
The computed parameter is mapped to the size of the nodes or edges. Mapping can be straight or inverse, that is, low parameter values can be mapped to small sizes or to large sizes. The smallest node size is set to 10 and the largest one to 100. Regarding edges, size reflects the edge line width and varies between 1 and 8. Refer to the documentation of Cytoscape's VizMapperTM if interested in fine-tuning the mapping parameters.

Map to node / edge color
A computed parameter is mapped to the color of the nodes or edges. Two mapping styles are possible - mapping low parameter values to bright colors or to dark colors. By default, the brightest color is green and the darkest color is red. The mapping also uses a middle (intermediate) color, which allows for fine-grained perception of differing values through the color gradient. The default middle color is yellow.

Figure 10
Figure 10 Map parameters to visual styles dialog

The default values for background, bright, middle and dark colors can be changed in the NetworkAnalyzer Settings menu option.

Plot Parameters
The Plot Parameters dialog offers a possibility to plot two parameters against each other. One possible application of such a plot is to observe the correlation of two parameters as shown on Figure 11. The parameters to be plotted can be chosen from two drop-down menus. The Attrbiute 1 menu provides the values for the domain/category axis, and the Attribute 2 menu specifies the values for the range/value axis. The plot is updated each time a different parameter is selected in one of the menus.

Figure 11
Figure 11 Plot parameters dialog

Network Modifications

In addition to topological analysis, NetworkAnalyzer offers a useful set of network modifications.

Remove Duplicated Edges
NetworkAnalyzer can remove duplicated edges in a network. After applying this operation to a network, every node pair (a, b) is connected by at most three edges - a directed edge from a to b, a directed edge from b to a, and an undirected edge. For each of these edge types, if there are more than one edge, one is randomly chosen and all others are removed from the network. Any attributes of the considered edges, if present, are ignored. If the option "Ignore edge direction" is selected, all edges are treated as undirected and thus only one edge per node pair is retained.

This option does not affect self-loops in the network. All duplicated self-loops, if any, are retained.

Please note that this option effectively modifies the selected network(s) and the operations performed cannot be undone.

Remove Self-Loops
NetworkAnalyzer can remove self-loops in a network. A self-loop is an edge which connects a node to itself. By applying this operation to a network, all directed and undirected self-loops are removed.

This option does not affect any other edges present in the network.

Please note that this option effectively modifies the selected network(s) and the operations performed cannot be undone.

Network Operations
NetworkAnalyzer can compute the union, intersection and difference of any two networks. The result of such operation is stored as a new network in Cytoscape.

NetworkAnalyzer computes these set operations two networks both on the node and on the edge levels. Note that every network is a pair of a node set and an edge set (N, E). Set operations - union, intersection and difference - are performed on both the node sets and the edge sets of networks.

Connected Components
NetworkAnalyzer can list all its connected components of a disconnected network. The size (number of nodes) of each component is reported. By selecting a specific connected component, it can be exported as a separate network in Cytoscape. This feature allows users to perform topological analysis on the largest connected component of a network.

References

[1]	Barabási, A.L., Albert, R.: Emergence of scaling in random networks. Science 286 (1999) 509-512
[2]	Barabási, A.L., Oltvai, Z.N.: Network biology: understanding the cell's functional organization. Nat Rev Genet 5 (2004) 101-113
[3]	Bollobas, B.: Random graphs. Cambridge University Press, Cambridge (2001), ISBN: 0-521-80920-7
[4]	Brandes, U.: A faster algorithm for betweenness centrality. J Math Sociol 25 (2001) 163-177
[5]	Diestel, R.: Graph theory. Springer-Verlag, Heidelberg (2005), ISBN 3-540-26182-6
[6]	Dong, J., Horvath, S.: Understanding network concepts in modules. BMC Syst Biol 24 (2007)
[7]	Erdős, P., Renyi, A.: Publ Math Inst Hung Acad Sci 5 (1960) 17
[8]	Goldstein, M.L., Morris, S.A., Yena, G.G.: Problems with fitting to the power-law distribution. European Physical Journal B 41 (2004) 255-258
[9]	Hastie, T., Tibshirani, R., Friedman, J.: The Elements of Statistical Learning. Springer-Verlag (2001), ISBN 0-387-95284-5
[10]	Maslov, S., Sneppen, K: Specificity and stability in topology of protein networks. Science 296 (2002) 910-913.
[11]	Newman, M.E.J.: A measure of betweenness centrality based on random walks. arXiv (2003) cond-mat/0309045
[12]	Newman, M.E.J., Girvan, M.: Finding and evaluating community structure in networks. Soc Networks 27 (2005) 39-54
[13]	Ravasz, E., et al.: Hierarchical organization of modularity in metabolic networks. Science 297 (2002) 1551-1555
[14]	Shimbel, A.: Structural parameters of communication networks. Bull Math Biophys 15 (1953) 501-507.
[15]	Stelzl, U., et al.: A human protein-protein interaction network: a resource for annotating the proteome. Cell 122 (2005) 957-968.
[16]	Tanaka, R., Yi, T.M, Doyle, J.: Some protein interaction data do not exhibit power law statistics. FEBS Letters 579 (2005) 5140-5144
[17]	Watts D.J., Strogatz, S.H.: Collective dynamics of 'small-world' networks. Nature 393 (1998) 440-442
[18]	Weisstein, E. W.: Least Squares Fitting - Power Law. MathWorld - A Wolfram Web Resource.
(http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html)
[19]	Yoon, J., Blumer, A., Lee, K.: An algorithm for modularity analysis of directed and weighted biological networks based on edge-betweenness centrality.
Bioinformatics, 22 (2006) 3106-8




------------------

<br>

```{r }
sessionInfo()
```


```{r echo=FALSE, eval=FALSE}
# Degree distribution is the cumulative frequency of nodes with a given degree
# this, like degree() can be specified as "in", "out", or "all"
deg.distr <- degree.distribution(union_graph, cumulative = TRUE, mode = "total")
 
# Using the power.law.fit() function I can fit a power law to the degree distribution
power<-power.law.fit(union_graph_degree)

# The output of the power.law.fit() function tells me what the exponent of the power law is ($alpha)
# and the log-likelihood of the parameters used to fit the power law distribution ($logLik)
# Also, it performs a Kolmogov-Smirnov test to test whether the given degree distribution could have
# been drawn from the fitted power law distribution.
# The function thus gives me the test statistic ($KS.stat) and p-vaule ($KS.p) for that test
 
# Then I can plot the degree distribution
plot(deg.distr,log="xy",
ylim=c(.01,10),
bg="black",pch=21,
xlab="Degree",
ylab="Cumulative Frequency")
 
# And the expected power law distribution
lines(1:20,10*(1:20)^((-power$alpha)+1))
 
# Graphs typically have a Poisson distribution (if they are random),
# power law (preferential attachment), or truncated power law (many real networks) degree distribution
```
